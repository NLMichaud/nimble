######	KEYWORD PROCESSING OBJECTS

#Keyword Class and objects






keywordInfoClass <- setRefClass('keywordInfoClass',
                                fields = list(
                                    keyword = 'ANY',
                                    processor = 'ANY'))
                                    
                                    
values_keywordInfo <- keywordInfoClass(
    keyword = 'values',
    processor = function(code, nfProc){
      if(!isCodeArgBlank(code, 'accessor'))
      	return(code)
      if(isCodeArgBlank(code, 'model'))
      	stop('model argument missing from values call, with no accessor argument supplied')
      
      accessArgList <- list(model = code$model, nodes = code$nodes, logProb = FALSE)
      accessName <- modelVariableAccessorVector_setupCodeTemplate$makeName(accessArgList)
      addNecessarySetupCode(accessName, accessArgList, modelVariableAccessorVector_setupCodeTemplate, nfProc)
      	
      accessLengthArgList <- list(accessName = accessName)
      accessLengthName <- accessorVectorLength_setupCodeTemplate$makeName(accessLengthArgList)
      addNecessarySetupCode(accessLengthName, accessLengthArgList, accessorVectorLength_setupCodeTemplate, nfProc)

      newRunCode <- substitute(values(accessor = ACCESS_NAME), 
                               list(ACCESS_NAME = as.name(accessName)))
      return(newRunCode)
    })                                    
 
calculate_keywordInfo <- keywordInfoClass(
	keyword = 'calculate',
	processor = function(code, nfProc){
		if(!isCodeArgBlank(code, 'nodeFunctionVector'))
			return(code)
		nodeFunVec_ArgList <- list(model = code$model, nodes = code$nodes, includeData = TRUE)
		if(isCodeArgBlank(code, 'model'))
			stop('model argument missing from calculate, with no accessor argument supplied')
		if(isCodeArgBlank(code, 'nodes')){
			LHSnodes_ArgList <- list(model = code$model)
			LHSnodes_name <- allLHSNodes_SetupTemplate$makeName(LHSnodes_ArgList)
			addNecessarySetupCode(LHSnodes_name, LHSnodes_ArgList, allLHSNodes_SetupTemplate, nfProc)
			nodeFunVec_ArgList$nodes = as.name(LHSnodes_name)
			}
		nodeFunName <- nodeFunctionVector_SetupTemplate$makeName(nodeFunVec_ArgList)	
		addNecessarySetupCode(nodeFunName, nodeFunVec_ArgList, nodeFunctionVector_SetupTemplate, nfProc)
		newRunCode <- substitute(calculate(nodeFunctionVector = NODEFUNVEC_NAME),
											list(NODEFUNVEC_NAME = as.name(nodeFunName)))
		return(newRunCode)	
		}
	)
    

simulate_keywordInfo <- keywordInfoClass(
	keyword = 'simulate',
	processor = function(code, nfProc){
		if(!isCodeArgBlank(code, 'nodeFunctionVector'))
			return(code)
		nodeFunVec_ArgList <- list(model = code$model, nodes = code$nodes, includeData = code$includeData)
		if(isCodeArgBlank(code, 'model'))
			stop('model argument missing from simulate, with no accessor argument supplied')
		if(isCodeArgBlank(code, 'nodes')){
			LHSnodes_ArgList <- list(model = code$model)
			LHSnodes_name <- allLHSNodes_SetupTemplate$makeName(LHSnodes_ArgList)
			addNecessarySetupCode(LHSnodes_name, LHSnodes_ArgList, allLHSNodes_SetupTemplate, nfProc)
			nodeFunVec_ArgList$nodes = as.name(LHSnodes_name)
			}
		nodeFunName <- nodeFunctionVector_SetupTemplate$makeName(nodeFunVec_ArgList)	
		addNecessarySetupCode(nodeFunName, nodeFunVec_ArgList, nodeFunctionVector_SetupTemplate, nfProc)
		newRunCode <- substitute(simulate(nodeFunctionVector = NODEFUNVEC_NAME),
											list(NODEFUNVEC_NAME = as.name(nodeFunName)))
		return(newRunCode)	
		}
	)

getLogProb_keywordInfo <- keywordInfoClass(
	keyword = 'getLogProb',
	processor = function(code, nfProc){
		if(!isCodeArgBlank(code, 'nodeFunctionVector'))
			return(code)
		nodeFunVec_ArgList <- list(model = code$model, nodes = code$nodes, includeData = TRUE)
		if(isCodeArgBlank(code, 'model'))
			stop('model argument missing from getLogProb, with no accessor argument supplied')
		if(isCodeArgBlank(code, 'nodes')){
			LHSnodes_ArgList <- list(model = code$model)
			LHSnodes_name <- allLHSNodes_SetupTemplate$makeName(LHSnodes_ArgList)
			addNecessarySetupCode(LHSnodes_name, LHSnodes_ArgList, allLHSNodes_SetupTemplate, nfProc)
			nodeFunVec_ArgList$nodes = as.name(LHSnodes_name)
			}
		nodeFunName <- nodeFunctionVector_SetupTemplate$makeName(nodeFunVec_ArgList)	
		addNecessarySetupCode(nodeFunName, nodeFunVec_ArgList, nodeFunctionVector_SetupTemplate, nfProc)
		newRunCode <- substitute(getLogProb(nodeFunctionVector = NODEFUNVEC_NAME),
											list(NODEFUNVEC_NAME = as.name(nodeFunName)))
		return(newRunCode)	
		}
	)    

nimCopy_keywordInfo <- keywordInfoClass(
	keyword = 'nimCopy',
	processor = function(code, nfProc){
		possibleObjects <- c('Model', 'ModelValues', 'ModelVariableAccessorVector', 'ModelValuesAccessorVector')
		modelValuesTypes <- c('ModelValues', 'ModelValuesAccessorVector')
		accessTypes <- c('ModelVariableAccessorVector', 'ModelValuesAccessorVector')
		from_ArgList <- list(name = code$from, class = symTypeFromSymTab(code$from, nfProc$setupSymTab, options = possibleObjects))
		to_ArgList <- list(name = code$to, class = symTypeFromSymTab(code$to, nfProc$setupSymTab, options = possibleObjects))
		if(from_ArgList$class %in% modelValuesTypes){
			if(isCodeArgBlank(code, 'row'))		stop('row argument missing in copy call')
			from_ArgList$row = code$row
		}
		if(to_ArgList$class %in% modelValuesTypes){
			if(isCodeArgBlank(code, 'rowTo')){
				if(isCodeArgBlank(code, 'row'))		stop('row argument missing in copy call')
				else								to_ArgList$row = code$row
			}
			else		to_ArgList$row = code$rowTo
		}
		if(isCodeArgBlank(code, 'nodes')){
			if(from_ArgList$class == 'Model'){
				node_ArgList <- list(model = from_ArgList$name)
				allNodes_name <- allModelNodes_SetupTemplate$makeName( node_ArgList )
				addNecessarySetupCode(allNodes_name, node_ArgList, allModelNodes_SetupTemplate, nfProc)
			}
			else if(from_ArgList$class == 'ModelValues'){
				from_ArgList$row = code$row
				mvVar_ArgList <- list(modelValues = from_ArgList$name)
				allNodes_name <- allModelValuesVars_SetupTemplate$makeName(mvVar_ArgList)
				addNecessarySetupCode(allNodes_name, mvVar_ArgList, allModelValuesVars_SetupTemplate, nfProc)
			}
			from_ArgList$nodes <- as.name(allNodes_name)
		}
		else	from_ArgList$nodes <- code$nodes
		
		if(isCodeArgBlank(code, 'nodesTo'))		to_ArgList$nodes <- from_ArgList$nodes
		else									to_ArgList$nodes <- code$nodesTo
				
		if(from_ArgList$class == 'Model'){
			accessFrom_ArgList <- list(model = code$from, nodes = from_ArgList$nodes, logProb = code$logProb)
			accessFrom_name <- modelVariableAccessorVector_setupCodeTemplate$makeName(accessFrom_ArgList)
			addNecessarySetupCode(accessFrom_name, accessFrom_ArgList, modelVariableAccessorVector_setupCodeTemplate, nfProc)
		}
		else if(from_ArgList$class == 'ModelValues'){
			accessFrom_ArgList <- list(modelValues = code$from, nodes = from_ArgList$nodes, logProb = code$logProb)
			accessFrom_name <- modelValuesAccessorVector_setupCodeTemplate$makeName(accessFrom_ArgList)
			addNecessarySetupCode(accessFrom_name, accessFrom_ArgList, modelValuesAccessorVector_setupCodeTemplate, nfProc)
		}
		else if(from_ArgList$class %in% accessTypes)
			accessFrom_name <- as.character(code$from)
		
		if(to_ArgList$class == 'Model'){
			accessTo_ArgList <- list(model = code$to, nodes = to_ArgList$nodes, logProb = code$logProb)
			accessTo_name <- modelVariableAccessorVector_setupCodeTemplate$makeName(accessTo_ArgList)
			addNecessarySetupCode(accessTo_name, accessTo_ArgList, modelVariableAccessorVector_setupCodeTemplate, nfProc)
		}
		else if(to_ArgList$class == 'ModelValues'){
			accessTo_ArgList <- list(modelValues = code$to, nodes = to_ArgList$nodes, logProb = code$logProb)
			accessTo_name <- modelValuesAccessorVector_setupCodeTemplate$makeName(accessTo_ArgList)
			addNecessarySetupCode(accessTo_name, accessTo_ArgList, modelValuesAccessorVector_setupCodeTemplate, nfProc)
		}
		else if(to_ArgList$class %in% accessTypes)
			accessTo_name <- as.character(code$to)
			
		#What happens below is a bit convoluted and really for backwards compatibility 	
		runCode <- substitute(nimCopy(from = FROM_ACCESS, rowFrom = NA, to = TO_ACCESS, rowTo = NA), 
							  list(FROM_ACCESS = as.name(accessFrom_name), TO_ACCESS = as.name(accessTo_name)))
		if(from_ArgList$class %in% modelValuesTypes)
			runCode$rowFrom = from_ArgList$row
		if(to_ArgList$class %in% modelValuesTypes)
			runCode$rowTo = to_ArgList$row
		runCode <- runCode[as.character(runCode) != 'NA']
		
		return(runCode)
	})

#	Need to get setupCodeTemplates working first...
doubleBracket_keywordInfo <- keywordInfoClass(
	keyword = '[[', 
	processor = function(code, nfProc){
		possibleObjects <- c('Model', 'NimPtrList', 'NimbleFunctionList')
		class = symTypeFromSymTab(code[[2]], nfProc$setupSymTab, options = possibleObjects)
		if(class == 'NimPtrList' || class == 'NimbleFunctionList')
			return(code)
		if(class == 'Model'){
			singleAccess_ArgList <- list(code = code, model = code[[2]], nodeExpr = code[[3]])
			nodeArg <- code[[3]]
			if(is.character(nodeArg)){
				varAndIndices <- getVarAndIndices(nodeArg)
				nDim <- sum(1 - unlist(lapply(varAndIndices$indices, is.numeric) ) )
				useMap <- nDim > 0
			}
			else{
				allNDims <- determineNdimsFromNfproc(singleAccess_ArgList$model, nodeArg, nfProc)
				if(length(unique(allNDims)) > 1) stop(paste0('Error for ', deparse(code), '. Inconsistent numbers of dimensions for different instances.'))
				nDim <- allNDims[[1]]
				useMap <- nDim > 0
			}
			if(useMap){
				accessName <- map_SetupTemplate$makeName(singleAccess_ArgList)
				addNecessarySetupCode(accessName, singleAccess_ArgList, map_SetupTemplate, nfProc)	
				ans <- makeMapAccessExpr(accessName, as.name(accessName), nDim)
			}
			else{
				accessName <- singleModelIndexAccess_SetupTemplate$makeName(singleAccess_ArgList)
				addNecessarySetupCode(accessName, singleAccess_ArgList, singleModelIndexAccess_SetupTemplate, nfProc)
				#ans <- substitute(ACCESSNAME[MFLATINDEX], list(ACCESSNAME = as.name(accessName), MFLATINDEX = as.name(paste0(accessName, '_flatIndex'))))
				ans <- makeSingleIndexAccessExpr(accessName, as.name(accessName))
			}
			return(ans)			
		}
	})

dollarSign_keywordInfo <- keywordInfoClass(
	keyword = '$',
	processor = function(code, nfProc){
		possibleObjects <- c('Model', 'NimPtrList')
		class <- symTypeFromSymTab(code[[2]], nfProc$setupSymTab, options = possibleObjects)
		if(class == 'NimPtrList')
			return(code)
		if(class == 'Model'){
			singleAccess_ArgList <- list(code = code, model = code[[2]], var = as.character(code[[3]]) )
			accessName <- singleVarAccess_SetupTemplate$makeName(singleAccess_ArgList)
			addNecessarySetupCode(accessName, singleAccess_ArgList, singleVarAccess_SetupTemplate, nfProc)
			return(as.name(accessName))
		}
	}
)
    
singleBracket_keywordInfo <- keywordInfoClass(
	keyword = '[',
	processor = function(code, nfProc){
		class <- symTypeFromSymTab(code[[2]], nfProc$setupSymTab)
		if(class == 'ModelValues'){
			singleMVAccess_ArgList <- list(code = code, modelValues = code[[2]], var = code[[3]], row = code[[4]])
			accessName <- singleModelValuesAccessor_SetupTemplate$makeName(singleMVAccess_ArgList)
			addNecessarySetupCode(accessName, singleMVAccess_ArgList, singleModelValuesAccessor_SetupTemplate, nfProc)
			return(as.name(accessName))
		}
	return(code)
	}
)    
    
    
#	KeywordList
keywordList <- new.env()
keywordList[['values']] <- values_keywordInfo
keywordList[['calculate']] <- calculate_keywordInfo
keywordList[['simulate']] <- simulate_keywordInfo
keywordList[['getLogProb']] <- getLogProb_keywordInfo
keywordList[['nimCopy']] <- nimCopy_keywordInfo
keywordList[['[[']] <- doubleBracket_keywordInfo
keywordList[['$']] <- dollarSign_keywordInfo
keywordList[['[']] <- singleBracket_keywordInfo
# necessary keywords:
#	calculate 	(done)
#	simulate	(done)
#	getLogProb	(done)
#	values		(done)
#	getValues	(removed from DSL)
#	setValues	(removed from DSL)
#	nimCopy		(done)
#	[[			(done)
#	$			(done)
#	[			(done)
#	resize		(special processing only for numericLists, not really used)
#	setSize		(special processing only for numericLists, not really used)
#	getSize		(special processing only for numericLists, not really used)
#	Also see replaceAccessorsOneFunction


#	processKeyword function to be called by nfProc
processKeyword <- function(code, nfProc){
  thisKeywordInfo <- keywordList[[ as.character(code[[1]]) ]]
  if(!is.null(thisKeywordInfo))
    return(thisKeywordInfo$processor(code, nfProc))
  return(code)
}







#####	SETUPCODE TEMPLATES

setupCodeTemplateClass <- setRefClass('setupCodeTemplateClass',
                                      fields = list(
                                          makeName = 'ANY',
                                          codeTemplate = 'ANY',
                                          makeCodeSubList = 'ANY',
                                          makeOtherNames = 'ANY'),
                                          methods = list(
                                          initialize = function(...){
                                          	makeOtherNames <<- function(name, argList)	return(character(0))
                                          	callSuper(...)
                                          }
                                          ) )
                                          
                                          
modelVariableAccessorVector_setupCodeTemplate <- setupCodeTemplateClass(
	#Note to programmer: required fields of argList are model, nodes and logProb

    makeName = function(argList) {Rname2CppName(paste(argList$model, argList$nodes, 'access_logProb', argList$logProb, sep = '_'))},
    codeTemplate = quote( ACCESSNAME <- modelVariableAccessorVector(MODEL, NODES, logProb = LOGPROB) ),
	makeCodeSubList = function(resultName, argList) {
        list(ACCESSNAME = as.name(resultName),
             MODEL = argList$model,
             NODES = argList$nodes,
             LOGPROB = argList$logProb)
    })

modelValuesAccessorVector_setupCodeTemplate <- setupCodeTemplateClass(
	#Note to programmer: required fields of argList are model, nodes and logProb

    makeName = function(argList) {Rname2CppName(paste(argList$model, argList$nodes, 'access_logProb', argList$logProb, sep = '_'))},
    codeTemplate = quote( ACCESSNAME <- modelValuesAccessorVector(MODEL, NODES, logProb = LOGPROB) ),
	makeCodeSubList = function(resultName, argList) {
        list(ACCESSNAME = as.name(resultName),
             MODEL = argList$model,
             NODES = argList$nodes,
             LOGPROB = argList$logProb)
    })


    
accessorVectorLength_setupCodeTemplate <- setupCodeTemplateClass(
  #Note to programmer: required fields of argList are accessName
 
  makeName = function(argList){ Rname2CppName(paste(argList$accessName, 'length', sep = '_')) },
  codeTemplate = quote(ACCESSLENGTH <- ACCESSNAME$length),
  makeCodeSubList = function(resultName, argList){
  	list(ACCESSNAME = as.name(argList$accessName),
  		ACCESSLENGTH = as.name(resultName) )
  	})


nodeFunctionVector_SetupTemplate <- setupCodeTemplateClass(
	#Note to programmer: required fields of argList are model, nodes and includeData
	
	makeName = function(argList){Rname2CppName(paste(argList$model, argList$nodes, 'nodeFxnVector_includeData', argList$includeData, sep = '_'))},
	codeTemplate = quote(NODEFXNVECNAME <- nodeFunctionVector(model = MODEL, nodeNames = NODES, excludeData = EXCLUDEDATA)), 
	makeCodeSubList = function(resultName, argList){
		list(NODEFXNVECNAME = as.name(resultName),
			MODEL = argList$model,
			NODES = argList$nodes,
			EXCLUDEDATA = !argList$includeData)
	})

allLHSNodes_SetupTemplate <- setupCodeTemplateClass(
	#Note to programmer: required fields of argList are model

	makeName = function(argList){
		Rname2CppName(paste('allLHSnodes', argList$model, sep = '_'))
	},
	codeTemplate = quote(NODENAMES <- MODEL$getMaps('nodeNamesLHSall')),
	makeCodeSubList = function(resultName, argList){
		list(NODENAMES = as.name(resultName),
			MODEL = argList$model)
	})
	
allModelNodes_SetupTemplate <- setupCodeTemplateClass(
	#Note to programmer: required fields of argList are model

	makeName = function(argList){
		Rname2CppName(paste('allModelNodes', argList$model, sep = '_'))
	},
	codeTemplate = quote(NODENAMES <- MODEL$getNodeNames()),
	makeCodeSubList = function(resultName, argList){
		list(NODENAMES = as.name(resultName),
			MODEL = argList$model)
	})	
	
allModelValuesVars_SetupTemplate <- setupCodeTemplateClass(
	#Note to programmer: required fields of argList are modelValues

	makeName = function(argList){
		Rname2CppName(paste('allMVVars', argList$modelValues, sep = '_'))
	},
	codeTemplate = quote(NODENAMES <- MODELVALUES$getVarNames(includeLogProb = FALSE)),	
		
	makeCodeSubList = function(resultName, argList){
		list(NODENAMES = as.name(resultName),
			MODELVALUES = argList$modelValues)
	})	
	
code2Name_fromArgList <- function(argList)
	Rname2CppName(deparse(argList$code))	
	
singleVarAccess_SetupTemplate <- setupCodeTemplateClass(
	#Note to progammer: required fields of argList are 'code' (raw code to be processed), model and var

	makeName = code2Name_fromArgList,

	codeTemplate = quote(SINGLEACCESSOR <- singleVarAccess(MODEL, VAR)),

	makeCodeSubList = function(resultName, argList){
		list(SINGLEACCESSOR = as.name(resultName),
			MODEL = argList$model,
			VAR = argList$var)	
	})	
	
singleModelIndexAccess_SetupTemplate <- setupCodeTemplateClass(
	#Note to progammer: required fields of argList are code, varAndIndices, node (character) and model(expression)
	makeOtherNames = function(name, argList){ paste0(name, '_flatIndex')},
	makeName = code2Name_fromArgList,
	
	codeTemplate = quote({
		VARANDINDICES <- getVarAndIndices(NODEVARNAME)
		NEWVARNAME <- as.character(VARANDINDICES$varName)
		MFLATINDEX <- varAndIndices2flatIndex(VARANDINDICES, MODELVAREXPR$getVarInfo(NEWVARNAME))
		VARACCESSOR <- singleVarAccess(MODELVAREXPR, NEWVARNAME, useSingleIndex = TRUE)
	}),
	makeCodeSubList = function(resultName, argList){
		list(VARACCESSOR = as.name(resultName),
			VARANDINDICES = as.name(paste0(resultName, '_varAndIndices') ),
			NEWVARNAME = as.name(paste0(resultName, '_newVarName')),
			NODEVARNAME = argList$nodeExpr,
			MFLATINDEX = as.name(paste0(resultName, '_flatIndex')),
			MODELVAREXPR = argList$model)
	})
	
map_SetupTemplate <- setupCodeTemplateClass(
	#Note to programmer: required fields of argList are code, model
	makeName  = code2Name_fromArgList,
	makeOtherNames = function(name, argList){
		output <- character()
		output[1] = paste0(name, '_strides')
		output[2] = paste0(name, '_offset')
		output[3] = paste0(name, '_sizes')
		return(output)
	},
	codeTemplate = quote({
		VARANDINDICES <- getVarAndIndices(NODEVARNAME)
		NEWVARNAME <- as.character(VARANDINDICES$varName)
		mapParts <- varAndIndices2mapParts(VARANDINDICES, MODEL$getVarInfo(NEWVARNAME))
		MSTRIDES <- mapParts$strides
		MOFFSET <- mapParts$offset
		MSIZES <- mapParts$sizes
		VARACCESSOR <- singleVarAccess(model, NEWVARNAME)
	}),
	makeCodeSubList = function(resultName, argList){
		list(VARACCESSOR = as.name(resultName),
		NODEVARNAME =	argList$nodeExpr,		# as.name(paste0(resultName, '_newVarName')),
		NEWVARNAME = as.name(paste0(resultName, '_newVarName')),
		VARANDINDICES = as.name(paste0(resultName, '_varAndIndices')),
		MODEL = argList$model,
		MSTRIDES = as.name(paste0(resultName, '_strides')),
		MOFFSET = as.name(paste0(resultName, '_offset')),
		MSIZES = as.name(paste0(resultName, '_sizes')))
	})
	
singleModelValuesAccessor_SetupTemplate <- setupCodeTemplateClass(
	#Note to programmer: required fields of argList are modelValues, var, row, code
	makeName = code2Name_fromArgList,
	codeTemplate = quote({
		MVACCESS <- singleModelValuesAccess(MODELVALUES, VAR)
	}),
	makeCodeSubList = function(resultName, argList){
		list(MVACCESS = as.name(resultName),
		MODELVALUES = argList$modelValues,
		VAR = argList$var)
	}
)





#### KEYWORD PROCESSING UTILITIES


isCodeArgBlank <- function(code, arg){
	#return(nchar(code[[arg]]) == 0)
	return(is.null(code[[arg]]))
}

# Utility functions to make things a little neater
isSetupCodeGenerated <- function(name, nfProc)
	name %in% nfProc$newSetupOutputNames
addSetupCodeNames <- function(name, otherNames, nfProc)
	nfProc$newSetupOutputNames <- c(name, otherNames, nfProc$newSetupOutputNames)
addNewCode <- function(name, subList, template, nfProc)
	nfProc$newSetupCode[[name]] <- eval(substitute(substitute(TEMPLATE, subList), list(TEMPLATE = template$codeTemplate) ) )

addNecessarySetupCode <- function(name, argList, template, nfProc){
#	name <- template$makeName(argList)
	if(!isSetupCodeGenerated(name, nfProc)){
		addSetupCodeNames(name, template$makeOtherNames(name, argList), nfProc)
		subList <- template$makeCodeSubList(name, argList)
		addNewCode(name, subList, template, nfProc)
	}
}

symTypeFromSymTab <- function(codeName, symTab, options = character(0) ){
	if(is.language(codeName))
		codeName <- as.character(codeName)
	if(length(codeName) > 1)
		return('NULL')
	class <- gsub('symbol', '', class(symTab$symbols[[codeName]])[1])
	if(length(options) == 0)
		return(class)
	if(!(class %in% options))
		stop(paste('invalid class for object ', codeName, 'class provided = ', class) )
	return(class)
}

isSymbolType <- function(symTab, varName, symType)
	inherits(symTab$symbols[[varName]], symType)

matchAndFill.call <- function(def, call){
  theseFormals <- formals(def)
  theseFormals <- theseFormals[nchar(theseFormals) > 0]
  matchedCall <- match.call(def, call)
  missingArgs <- which(!(names(theseFormals) %in% names(matchedCall)))
  for(ind in missingArgs){
    name <- names(theseFormals)[ind]
    matchedCall[[name]] <- theseFormals[[name]]    
  }
  return(matchedCall)
}

pasteExpr <- function(expr1, expr2)
	parse(text=paste0(as.character(expr1), as.character(expr2) ) )[[1]]


determineNdimsFromNfproc <- function(modelExpr, varOrNodeExpr, nfProc) {
    allNDims <- lapply(nfProc$instances, function(x) {
        model <- eval(modelExpr, envir = x)
        if(!exists(as.character(varOrNodeExpr), x, inherits = FALSE) ) {
            stop(paste0('Error, ', as.character(varOrNodeExpr), ' does not exist in an instance of this nimbleFunction.'))
        }
        lab <- eval(varOrNodeExpr, envir = x)
        varAndIndices <- getVarAndIndices(lab)
        determineNdimFromOneCase(model, varAndIndices)
    } )
    return(allNDims)
}

matchFunctions <- new.env()
matchFunctions[['values']] <- function(model, nodes, accessor){}
matchFunctions[['calculate']] <- function(model, nodes, nodeFunctionVector){}
matchFunctions[['simulate']] <- function(model, nodes, includeData = FALSE, nodeFunctionVector){}
matchFunctions[['getLogProb']] <- function(model, nodes, nodeFunctionVector){}
matchFunctions[['nimCopy']] <- function(from, to, nodes, nodesTo, row, rowTo, logProb = FALSE){}

matchKeywordCode <- function(code){
	thisFunctionMatch <- matchFunctions[[ as.character( code[[1]] ) ]]
	if(!is.null(thisFunctionMatch))
		return(matchAndFill.call(thisFunctionMatch, code ) )
	return(code)
}